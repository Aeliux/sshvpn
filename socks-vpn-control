#!/usr/bin/env bash

# /usr/local/bin/socks-vpn-control

set -euo pipefail

# === CONFIGURE THESE if different ===
SOCKS_HOST=127.0.0.1
SOCKS_PORT=1080
TUND_EV=tun0
TUN_IP=198.18.0.1
TUN_NETMASK=255.255.255.0
HOSTNAME=dev.bugfreenet.online   # the SSH host name you use to create SOCKS
DNS_BACKUP=/etc/resolv.conf.socks-vpn.bak
# === end config ===

STATE_DIR=/run/socks-vpn
STATE_FILE="$STATE_DIR/state.env"

GATEWAY=""
IFACE=""
SERVER_IP=""

# helpers
log() { echo "[socks-vpn] $*"; }
die() { echo "ERROR: $*" >&2; exit 1; }

if [[ $EUID -ne 0 ]]; then
  echo "This script must be run as root (systemd will run it with proper privilege via polkit/ sudo if set)."
  exit 1
fi

resolve_server_ip() {
  getent hosts "$HOSTNAME" | awk '{print $1; exit}'
}

current_wan_route() {
  # pick the first v4 default route that has a gateway and is NOT the tunnel device
  ip -4 route show default 0.0.0.0/0 | awk -v dev="$TUND_EV" '$2=="via" && $5!=dev {print $3" "$5; exit}'
}

wait_for_wan() {
  local attempts=0
  while (( attempts < 30 )); do
    if route=$(current_wan_route); then
      echo "$route"
      return 0
    fi
    sleep 1
    attempts=$((attempts + 1))
  done
  return 1
}

ensure_gateway() {
  if route=$(current_wan_route); then
    read -r GATEWAY IFACE <<<"$route"
  elif route=$(wait_for_wan); then
    read -r GATEWAY IFACE <<<"$route"
  fi

  # validate gateway looks like IPv4 and iface not empty
  if [[ $GATEWAY =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ && -n $IFACE ]]; then
    return 0
  fi
  GATEWAY=""
  IFACE=""
  return 1
}

ensure_server_ip() {
  SERVER_IP=$(resolve_server_ip || true)
  [[ -n "$SERVER_IP" ]]
}

setup_tun() {
  ip tuntap add dev "$TUND_EV" mode tun || true
  ip addr add "$TUN_IP"/24 dev "$TUND_EV" || true
  ip link set dev "$TUND_EV" up
}

wait_for_socks_ready() {
  local attempts=${1:-12} # ~60s with 5s sleep below
  local ok=0
  while (( attempts > 0 )); do
    # quick TCP check to the local SOCKS port
    if timeout 2 bash -c "</dev/tcp/$SOCKS_HOST/$SOCKS_PORT" 2>/dev/null; then
      ok=1
    else
      ok=0
    fi

    if (( ok == 1 )) && command -v curl >/dev/null 2>&1; then
      # end-to-end check through SOCKS to a fixed IP (no DNS needed)
      if timeout 6 curl -sS --socks5-hostname "$SOCKS_HOST:$SOCKS_PORT" \
        --resolve one.one.one.one:443:1.1.1.1 https://one.one.one.one/cdn-cgi/trace -o /dev/null; then
        return 0
      fi
      ok=0
    fi

    attempts=$((attempts - 1))
    log "SOCKS not ready yet; retrying in 5s (remaining=$attempts)"
    sleep 5
  done
  return 1
}

start_tun2socks() {
  pkill -f "badvpn-tun2socks.*$TUND_EV" || true
  nohup /usr/bin/badvpn-tun2socks --tundev "$TUND_EV" \
    --netif-ipaddr "$TUN_IP" --netif-netmask "$TUN_NETMASK" \
    --socks-server-addr "$SOCKS_HOST:$SOCKS_PORT" > /var/tmp/badvpn-tun2socks.log 2>&1 &
}

ensure_routes() {
  if [[ -z "$SERVER_IP" ]]; then
    return 1
  fi
  if ! ensure_gateway; then
    log "No uplink route yet; will retry"
    return 1
  fi
  ip -4 route replace "$SERVER_IP"/32 via "$GATEWAY" dev "$IFACE" || log "Route for SSH server failed"
  ip -4 route replace default dev "$TUND_EV" metric 50 || log "Default via $TUND_EV failed"
  ip -4 route replace default via "$GATEWAY" dev "$IFACE" metric 100 || log "Fallback default via $GATEWAY failed"
  return 0
}

setup_dns() {
  if command -v resolvectl >/dev/null 2>&1; then
    log "Setting DNS for $TUND_EV to 1.1.1.1 via systemd-resolved"
    resolvectl dns "$TUND_EV" 1.1.1.1
    resolvectl domain "$TUND_EV" "~."
  else
    cp -n /etc/resolv.conf "$DNS_BACKUP" || true
    echo "nameserver 1.1.1.1" > /etc/resolv.conf
  fi
}

restore_dns() {
  if command -v resolvectl >/dev/null 2>&1; then
    resolvectl revert "$TUND_EV" || true
  else
    if [[ -f "$DNS_BACKUP" ]]; then
      mv "$DNS_BACKUP" /etc/resolv.conf
    fi
  fi
}

start_vpn() {
  ensure_server_ip || die "Cannot resolve $HOSTNAME"
  ensure_gateway || die "Cannot find default gateway/interface"
  if ! wait_for_socks_ready; then
    die "SOCKS proxy $SOCKS_HOST:$SOCKS_PORT not ready"
  fi
  log "Using gateway $GATEWAY dev $IFACE; server $SERVER_IP; socks $SOCKS_HOST:$SOCKS_PORT"

  setup_tun
  mkdir -p "$STATE_DIR"
  printf 'GATEWAY=%s\nIFACE=%s\nSERVER_IP=%s\n' "$GATEWAY" "$IFACE" "$SERVER_IP" > "$STATE_FILE"
  ensure_routes || log "Initial route setup deferred; will retry in monitor"
  start_tun2socks
  setup_dns
  log "socks-vpn started (tun: $TUND_EV). Check /var/tmp/badvpn-tun2socks.log for logs."
}

stop_vpn() {
  # Load saved state if available (ExecStop runs in new process)
  if [[ -f "$STATE_FILE" ]]; then
    # shellcheck disable=SC1090
    source "$STATE_FILE" || true
  fi
  [[ -n "$GATEWAY" && -n "$IFACE" ]] || ensure_gateway || true
  [[ -n "$SERVER_IP" ]] || ensure_server_ip || true

  restore_dns
  if [[ -n "$GATEWAY" && -n "$IFACE" ]]; then
    ip -4 route replace default via "$GATEWAY" dev "$IFACE" metric 100 || true
  fi
  ip -4 route del default dev "$TUND_EV" || true
  pkill -f "badvpn-tun2socks.*$TUND_EV" || true
  sleep 0.5
  ip link set dev "$TUND_EV" down || true
  ip tuntap del dev "$TUND_EV" mode tun || true
  if [[ -n "$SERVER_IP" && -n "$GATEWAY" && -n "$IFACE" ]]; then
    ip -4 route del "$SERVER_IP"/32 via "$GATEWAY" dev "$IFACE" || true
  fi
  rm -f "$STATE_FILE" || true
  log "socks-vpn stopped and cleaned."
}

monitor_loop() {
  trap 'exit 0' INT TERM
  local dns_fail=0
  local gw_fail=0
  while true; do
    if ! ensure_server_ip; then
      dns_fail=$((dns_fail + 1))
      log "Cannot resolve $HOSTNAME; retrying (dns_fail=$dns_fail)"
    else
      dns_fail=0
    fi

    if ! ensure_routes; then
      gw_fail=$((gw_fail + 1))
      log "No uplink route yet; retrying (gw_fail=$gw_fail)"
    else
      gw_fail=0
    fi

    if (( dns_fail >= 5 || gw_fail >= 5 )); then
      log "Recycling VPN after repeated failures (dns_fail=$dns_fail gw_fail=$gw_fail)"
      stop_vpn
      sleep 5
      start_vpn
      dns_fail=0
      gw_fail=0
      continue
    fi
    if ! pgrep -f "badvpn-tun2socks.*$TUND_EV" >/dev/null; then
      log "Restarting badvpn-tun2socks"
      start_tun2socks
    fi
    sleep 5
  done
}

status_vpn() {
  ip addr show dev "$TUND_EV" || true
  pgrep -af "badvpn-tun2socks" || true
  ip route show default || true
}

case "${1:-}" in
  start)
    start_vpn
    ;;
  daemon)
    start_vpn
    monitor_loop
    ;;
  stop)
    stop_vpn
    ;;
  status)
    status_vpn
    ;;
  *)
    echo "Usage: $0 {start|stop|status|daemon}"
    exit 2
    ;;
 esac
