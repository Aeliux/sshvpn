#!/usr/bin/env bash

# /usr/local/bin/socks-vpn-control

set -euo pipefail

APP_NAME="socks-vpn"
CONFIG_FILE=${VPN_CONFIG:-/usr/local/etc/socks-vpn.conf}
STATE_DIR=/run/socks-vpn
STATE_FILE="$STATE_DIR/state.env"
DNS_BACKUP=/etc/resolv.conf.socks-vpn.bak

DEFAULT_LOCAL_BYPASS="127.0.0.0/8 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16 169.254.0.0/16"
DEFAULT_DNS="1.1.1.1"
DEFAULT_CHECK_TARGET="1.1.1.1"
DEFAULT_CHECK_INTERVAL=5

SSH_PID=""
TUN2SOCKS_PID=""
GATEWAY=""
IFACE=""
RUNNING=0
STOPPING=0

level_value() {
  case "${1,,}" in
    error) echo 0 ;;
    warn)  echo 1 ;;
    info)  echo 2 ;;
    debug) echo 3 ;;
    *)     echo 2 ;;
  esac
}

LOG_LEVEL=${LOG_LEVEL:-info}
LOG_LEVEL_NUM=$(level_value "$LOG_LEVEL")

log() {
  local level=$1; shift
  local msg="$*"
  local current=$(level_value "$level")
  if (( current <= LOG_LEVEL_NUM )); then
    echo "[$APP_NAME][$level] $msg"
  fi
}

die() {
  log error "$*"
  exit 1
}

require_root() {
  if [[ $EUID -ne 0 ]]; then
    echo "This script must be run as root (systemd will handle privileges)." >&2
    exit 1
  fi
}

load_config() {
  if [[ ! -f "$CONFIG_FILE" ]]; then
    die "Config file $CONFIG_FILE missing"
  fi
  # shellcheck disable=SC1090
  source "$CONFIG_FILE"

  LOG_LEVEL=${LOG_LEVEL:-info}
  LOG_LEVEL_NUM=$(level_value "$LOG_LEVEL")

  SOCKS_HOST=${SOCKS_HOST:-127.0.0.1}
  SOCKS_PORT=${SOCKS_PORT:-1080}
  TUN_DEV=${TUN_DEV:-tun0}
  TUN_IP=${TUN_IP:-198.18.0.1}
  TUN_NETMASK=${TUN_NETMASK:-255.255.255.0}
  DNS_SERVER=${DNS_SERVER:-$DEFAULT_DNS}
  CHECK_TARGET=${CHECK_TARGET:-$DEFAULT_CHECK_TARGET}
  CHECK_INTERVAL=${CHECK_INTERVAL:-$DEFAULT_CHECK_INTERVAL}
  LOCAL_BYPASS_CIDRS=${LOCAL_BYPASS_CIDRS:-$DEFAULT_LOCAL_BYPASS}

  SSH_HOST_IP=${SSH_HOST_IP:-}
  SSH_PORT=${SSH_PORT:-22}
  SSH_USER=${SSH_USER:-}
  SSH_AUTH_METHOD=${SSH_AUTH_METHOD:-password}
  SSH_PASSWORD_FILE=${SSH_PASSWORD_FILE:-/usr/local/etc/ssh-socks.pass}
  SSH_IDENTITY_FILE=${SSH_IDENTITY_FILE:-}
  SSH_STRICT_HOST_KEY_CHECKING=${SSH_STRICT_HOST_KEY_CHECKING:-no}
  SSH_SERVER_ALIVE_INTERVAL=${SSH_SERVER_ALIVE_INTERVAL:-5}
  SSH_SERVER_ALIVE_COUNT_MAX=${SSH_SERVER_ALIVE_COUNT_MAX:-3}
  SSH_EXTRA_OPTS=${SSH_EXTRA_OPTS:-}
}

validate_config() {
  [[ -n "$SSH_HOST_IP" ]] || die "SSH_HOST_IP is required and must be an IP address"
  if [[ ! $SSH_HOST_IP =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
    die "SSH_HOST_IP must be an IPv4 address"
  fi
  [[ -n "$SSH_USER" ]] || die "SSH_USER is required"
  if [[ $SSH_AUTH_METHOD == "password" ]]; then
    [[ -r "$SSH_PASSWORD_FILE" ]] || die "SSH_PASSWORD_FILE $SSH_PASSWORD_FILE is not readable"
  elif [[ $SSH_AUTH_METHOD == "key" ]]; then
    [[ -r "$SSH_IDENTITY_FILE" ]] || die "SSH_IDENTITY_FILE $SSH_IDENTITY_FILE is not readable"
  else
    die "SSH_AUTH_METHOD must be password or key"
  fi
}

current_wan_route() {
  ip -4 route show default 0.0.0.0/0 | awk -v dev="$TUN_DEV" '$2=="via" && $5!=dev {print $3" "$5; exit}'
}

wait_for_wan() {
  local attempts=0
  while (( attempts < 30 )); do
    if route=$(current_wan_route); then
      echo "$route"
      return 0
    fi
    sleep 1
    attempts=$((attempts + 1))
  done
  return 1
}

ensure_gateway() {
  if route=$(current_wan_route); then
    read -r GATEWAY IFACE <<<"$route"
  elif route=$(wait_for_wan); then
    read -r GATEWAY IFACE <<<"$route"
  fi

  if [[ $GATEWAY =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ && -n $IFACE ]]; then
    return 0
  fi
  GATEWAY=""
  IFACE=""
  return 1
}

setup_state_dir() {
  mkdir -p "$STATE_DIR"
}

persist_state() {
  setup_state_dir
  cat > "$STATE_FILE" <<EOF
GATEWAY=$GATEWAY
IFACE=$IFACE
SSH_HOST_IP=$SSH_HOST_IP
TUN_DEV=$TUN_DEV
TUN_IP=$TUN_IP
TUN_NETMASK=$TUN_NETMASK
LOCAL_BYPASS_CIDRS="$LOCAL_BYPASS_CIDRS"
MAIN_PID=$$
EOF
}

load_state() {
  if [[ -f "$STATE_FILE" ]]; then
    # shellcheck disable=SC1090
    source "$STATE_FILE"
  fi
}

setup_tun() {
  ip tuntap add dev "$TUN_DEV" mode tun 2>/dev/null || true
  ip addr add "$TUN_IP"/24 dev "$TUN_DEV" 2>/dev/null || true
  ip link set dev "$TUN_DEV" up
}

block_default_route() {
  ip -4 route replace default prohibit || true
}

add_server_route() {
  ip -4 route replace "$SSH_HOST_IP"/32 via "$GATEWAY" dev "$IFACE" || die "Failed to pin route to SSH host"
}

add_local_bypass_routes() {
  for cidr in $LOCAL_BYPASS_CIDRS; do
    ip -4 route replace "$cidr" via "$GATEWAY" dev "$IFACE" 2>/dev/null || true
  done
}

activate_tun_routes() {
  ip -4 route replace default dev "$TUN_DEV" metric 50 || die "Failed to direct default traffic to $TUN_DEV"
}

setup_dns() {
  if command -v resolvectl >/dev/null 2>&1; then
    log info "Setting DNS for $TUN_DEV to $DNS_SERVER"
    resolvectl dns "$TUN_DEV" "$DNS_SERVER"
    resolvectl domain "$TUN_DEV" "~."
  else
    cp -n /etc/resolv.conf "$DNS_BACKUP" 2>/dev/null || true
    echo "nameserver $DNS_SERVER" > /etc/resolv.conf
  fi
}

restore_dns() {
  if command -v resolvectl >/dev/null 2>&1; then
    resolvectl revert "$TUN_DEV" || true
  else
    if [[ -f "$DNS_BACKUP" ]]; then
      mv "$DNS_BACKUP" /etc/resolv.conf
    fi
  fi
}

start_ssh_socks() {
  local base_opts=(
    -o ExitOnForwardFailure=yes
    -o ServerAliveInterval=$SSH_SERVER_ALIVE_INTERVAL
    -o ServerAliveCountMax=$SSH_SERVER_ALIVE_COUNT_MAX
    -o StrictHostKeyChecking=$SSH_STRICT_HOST_KEY_CHECKING
    -o UserKnownHostsFile=/dev/null
    -o LogLevel=ERROR
    -p "$SSH_PORT"
    -N
    -D "$SOCKS_HOST:$SOCKS_PORT"
    "$SSH_USER@$SSH_HOST_IP"
  )

  if [[ -n "$SSH_EXTRA_OPTS" ]]; then
    # shellcheck disable=SC2206
    extra=( $SSH_EXTRA_OPTS )
    base_opts=("${extra[@]}" "${base_opts[@]}")
  fi

  if [[ $SSH_AUTH_METHOD == "password" ]]; then
    log info "Starting SSH SOCKS (password auth) to $SSH_HOST_IP:$SSH_PORT"
    sshpass -f "$SSH_PASSWORD_FILE" ssh "${base_opts[@]}" > /var/tmp/ssh-socks.log 2>&1 &
  else
    log info "Starting SSH SOCKS (key auth) to $SSH_HOST_IP:$SSH_PORT"
    ssh -i "$SSH_IDENTITY_FILE" "${base_opts[@]}" > /var/tmp/ssh-socks.log 2>&1 &
  fi

  SSH_PID=$!
  disown "$SSH_PID"
}

wait_for_socks_ready() {
  local attempts=${1:-12}
  local ok=0
  while (( attempts > 0 )); do
    if timeout 2 bash -c "</dev/tcp/$SOCKS_HOST/$SOCKS_PORT" 2>/dev/null; then
      ok=1
    else
      ok=0
    fi

    if (( ok == 1 )) && command -v curl >/dev/null 2>&1; then
      if timeout 6 curl -sS --socks5-hostname "$SOCKS_HOST:$SOCKS_PORT" \
        --resolve $CHECK_TARGET:443:$CHECK_TARGET -k "https://$CHECK_TARGET" -o /dev/null; then
        return 0
      fi
      ok=0
    fi

    attempts=$((attempts - 1))
    log warn "SOCKS not ready; retrying in 5s (remaining=$attempts)"
    sleep 5
  done
  return 1
}

start_tun2socks() {
  pkill -f "badvpn-tun2socks.*$TUN_DEV" 2>/dev/null || true
  log info "Starting badvpn-tun2socks on $TUN_DEV"
  /usr/bin/badvpn-tun2socks --tundev "$TUN_DEV" \
    --netif-ipaddr "$TUN_IP" --netif-netmask "$TUN_NETMASK" \
    --socks-server-addr "$SOCKS_HOST:$SOCKS_PORT" > /var/tmp/badvpn-tun2socks.log 2>&1 &
  TUN2SOCKS_PID=$!
  disown "$TUN2SOCKS_PID"
}

check_connectivity() {
  local target_ip=${1:-$CHECK_TARGET}
  if command -v curl >/dev/null 2>&1; then
    if timeout 8 curl -fsS --max-time 8 --connect-timeout 4 -k "https://${target_ip}/" -o /dev/null; then
      return 0
    fi
  fi
  if timeout 4 bash -c "</dev/tcp/${target_ip}/443" 2>/dev/null; then
    return 0
  fi
  return 1
}

stop_processes() {
  if [[ -n "$SSH_PID" ]] && kill -0 "$SSH_PID" 2>/dev/null; then
    kill "$SSH_PID" 2>/dev/null || true
  fi
  if [[ -n "$TUN2SOCKS_PID" ]] && kill -0 "$TUN2SOCKS_PID" 2>/dev/null; then
    kill "$TUN2SOCKS_PID" 2>/dev/null || true
  fi
  pkill -f "badvpn-tun2socks.*$TUN_DEV" 2>/dev/null || true
}

teardown_routes() {
  ip -4 route del default dev "$TUN_DEV" 2>/dev/null || true
  ip -4 route del default prohibit 2>/dev/null || true
  if [[ -n "$GATEWAY" && -n "$IFACE" ]]; then
    ip -4 route replace default via "$GATEWAY" dev "$IFACE" metric 100 2>/dev/null || true
  fi
  ip -4 route del "$SSH_HOST_IP"/32 via "$GATEWAY" dev "$IFACE" 2>/dev/null || true
  for cidr in $LOCAL_BYPASS_CIDRS; do
    ip -4 route del "$cidr" via "$GATEWAY" dev "$IFACE" 2>/dev/null || true
  done
}

teardown_tun() {
  ip link set dev "$TUN_DEV" down 2>/dev/null || true
  ip tuntap del dev "$TUN_DEV" mode tun 2>/dev/null || true
}

stop_vpn() {
  if (( STOPPING == 1 )); then
    return
  fi
  STOPPING=1
  load_state
  restore_dns
  stop_processes
  teardown_routes
  teardown_tun
  rm -f "$STATE_FILE" 2>/dev/null || true
  log info "socks-vpn stopped and cleaned."
}

handle_signal() {
  local sig=$1
  log warn "Received $sig, stopping"
  RUNNING=0
  stop_vpn
  exit 0
}

monitor_loop() {
  while (( RUNNING == 1 )); do
    if [[ -n "$SSH_PID" ]] && ! kill -0 "$SSH_PID" 2>/dev/null; then
      log warn "SSH SOCKS process died; restarting"
      start_ssh_socks
      if ! wait_for_socks_ready 6; then
        log warn "SOCKS still not ready; will retry"
      fi
    fi

    if [[ -n "$TUN2SOCKS_PID" ]] && ! kill -0 "$TUN2SOCKS_PID" 2>/dev/null; then
      log warn "badvpn-tun2socks exited; restarting"
      start_tun2socks
    fi

    if ! check_connectivity "$CHECK_TARGET"; then
      log warn "Connectivity check failed; cycling datapath"
      start_tun2socks
      if [[ -n "$SSH_PID" ]] && kill -0 "$SSH_PID" 2>/dev/null; then
        :
      else
        start_ssh_socks
      fi
    fi

    sleep "$CHECK_INTERVAL"
  done
}

start_vpn() {
  require_root
  load_config
  validate_config
  ensure_gateway || die "Cannot find default gateway/interface"

  block_default_route
  add_server_route
  add_local_bypass_routes

  log info "Using gateway $GATEWAY dev $IFACE; server $SSH_HOST_IP; socks $SOCKS_HOST:$SOCKS_PORT"

  setup_tun
  start_ssh_socks
  if ! wait_for_socks_ready; then
    stop_processes
    teardown_routes
    teardown_tun
    restore_dns
    die "SOCKS proxy $SOCKS_HOST:$SOCKS_PORT not ready"
  fi

  start_tun2socks
  activate_tun_routes
  setup_dns
  persist_state
  log info "socks-vpn started (tun: $TUN_DEV)."
}

status_vpn() {
  ip addr show dev "$TUN_DEV" || true
  pgrep -af "badvpn-tun2socks" || true
  ip route show default || true
}

stop_command() {
  load_state
  if [[ -n ${MAIN_PID:-} && "$MAIN_PID" != "$$" ]] && kill -0 "$MAIN_PID" 2>/dev/null; then
    log info "Signaling running daemon (pid=$MAIN_PID)"
    kill -TERM "$MAIN_PID"
    exit 0
  fi
  stop_vpn
}

case "${1:-}" in
  start)
    start_vpn
    ;;
  daemon)
    trap 'handle_signal TERM' TERM
    trap 'handle_signal INT' INT
    start_vpn
    RUNNING=1
    monitor_loop
    ;;
  stop)
    stop_command
    ;;
  status)
    status_vpn
    ;;
  *)
    echo "Usage: $0 {start|stop|status|daemon}"
    exit 2
    ;;
esac
