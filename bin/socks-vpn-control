#!/usr/bin/env bash

# /usr/lib/socks-vpn/socks-vpn-daemon

set -euo pipefail

CONFIG_FILE=${VPN_CONFIG:-/etc/socks-vpn.conf}

DEFAULT_LOCAL_BYPASS="127.0.0.0/8 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16 169.254.0.0/16"
DEFAULT_DNS="1.1.1.1"
DEFAULT_CHECK_TARGET="1.1.1.1"
DEFAULT_CHECK_INTERVAL=5

SSH_PID=""
TUN2SOCKS_PID=""
GATEWAY=""
IFACE=""
RESOLVED_SSH_IP=""
RUNNING=0
STOPPING=0

level_value() {
  case "${1,,}" in
    error) echo 0 ;;
    warn)  echo 1 ;;
    info)  echo 2 ;;
    debug) echo 3 ;;
    *)     echo 2 ;;
  esac
}

LOG_LEVEL=${LOG_LEVEL:-info}
LOG_LEVEL_NUM=$(level_value "$LOG_LEVEL")

log() {
  local current
  local level=$1; shift
  local msg="$*"
  current=$(level_value "$level")
  if (( current <= LOG_LEVEL_NUM )); then
    echo "$msg"
  fi
}

die() {
  log error "$*"
  exit 1
}

require_root() {
  if [[ $EUID -ne 0 ]]; then
    echo "This script must be run as root (systemd will handle privileges)." >&2
    exit 1
  fi
}

load_config() {
  if [[ ! -f "$CONFIG_FILE" ]]; then
    die "Config file $CONFIG_FILE missing"
  fi
  # shellcheck disable=SC1090
  source "$CONFIG_FILE"

  LOG_LEVEL=${LOG_LEVEL:-info}
  LOG_LEVEL_NUM=$(level_value "$LOG_LEVEL")

  SOCKS_HOST=${SOCKS_HOST:-127.0.0.1}
  SOCKS_PORT=${SOCKS_PORT:-1080}
  TUN_DEV=${TUN_DEV:-tun0}
  TUN_IP=${TUN_IP:-198.18.0.1}
  TUN_NETMASK=${TUN_NETMASK:-255.255.255.0}
  DNS_SERVER=${DNS_SERVER:-$DEFAULT_DNS}
  CHECK_TARGET=${CHECK_TARGET:-$DEFAULT_CHECK_TARGET}
  CHECK_INTERVAL=${CHECK_INTERVAL:-$DEFAULT_CHECK_INTERVAL}
  LOCAL_BYPASS_CIDRS=${LOCAL_BYPASS_CIDRS:-$DEFAULT_LOCAL_BYPASS}

  SSH_HOST=${SSH_HOST:-}
  SSH_PORT=${SSH_PORT:-22}
  SSH_USER=${SSH_USER:-}
  SSH_AUTH_METHOD=${SSH_AUTH_METHOD:-password}
  SSH_PASSWORD_FILE=${SSH_PASSWORD_FILE:-/etc/socks-vpn.pass}
  SSH_IDENTITY_FILE=${SSH_IDENTITY_FILE:-}
  SSH_SERVER_ALIVE_INTERVAL=${SSH_SERVER_ALIVE_INTERVAL:-5}
  SSH_SERVER_ALIVE_COUNT_MAX=${SSH_SERVER_ALIVE_COUNT_MAX:-3}
  SSH_EXTRA_OPTS=${SSH_EXTRA_OPTS:-}
}

validate_config() {
  [[ -n "$SSH_HOST" ]] || die "SSH_HOST is required"
  [[ -n "$SSH_USER" ]] || die "SSH_USER is required"
  if [[ $SSH_AUTH_METHOD == "password" ]]; then
    [[ -r "$SSH_PASSWORD_FILE" ]] || die "SSH_PASSWORD_FILE $SSH_PASSWORD_FILE is not readable"
    command -v sshpass >/dev/null 2>&1 || die "sshpass is required for password authentication"
  elif [[ $SSH_AUTH_METHOD == "key" ]]; then
    [[ -r "$SSH_IDENTITY_FILE" ]] || die "SSH_IDENTITY_FILE $SSH_IDENTITY_FILE is not readable"
  else
    die "SSH_AUTH_METHOD must be password or key"
  fi
  command -v resolvectl >/dev/null 2>&1 || die "resolvectl is required"
}

resolve_ssh_ip() {
  RESOLVED_SSH_IP=$(getent hosts "$SSH_HOST" | awk '{print $1; exit}')
  if [[ ! $RESOLVED_SSH_IP =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
    RESOLVED_SSH_IP=""
    return 1
  fi
  return 0
}

current_wan_route() {
  ip -4 route show default 0.0.0.0/0 | awk -v dev="$TUN_DEV" '$2=="via" && $5!=dev {print $3" "$5; exit}'
}

wait_for_wan() {
  local attempts=0
  while (( attempts < 30 )); do
    if route=$(current_wan_route); then
      echo "$route"
      return 0
    fi
    sleep 1
    attempts=$((attempts + 1))
  done
  return 1
}

ensure_gateway() {
  if route=$(current_wan_route); then
    read -r GATEWAY IFACE <<<"$route"
  elif route=$(wait_for_wan); then
    read -r GATEWAY IFACE <<<"$route"
  fi

  if [[ $GATEWAY =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ && -n $IFACE ]]; then
    return 0
  fi
  GATEWAY=""
  IFACE=""
  return 1
}

setup_tun() {
  ip tuntap add dev "$TUN_DEV" mode tun 2>/dev/null || true
  ip addr add "$TUN_IP"/24 dev "$TUN_DEV" 2>/dev/null || true
  ip link set dev "$TUN_DEV" up
}

block_default_route() {
  ip -4 route replace default prohibit || true
}

add_server_route() {
  ip -4 route replace "$RESOLVED_SSH_IP"/32 via "$GATEWAY" dev "$IFACE" || die "Failed to pin route to SSH host"
}

add_local_bypass_routes() {
  for cidr in $LOCAL_BYPASS_CIDRS; do
    ip -4 route replace "$cidr" via "$GATEWAY" dev "$IFACE" 2>/dev/null || true
  done
}

activate_tun_routes() {
  ip -4 route replace default dev "$TUN_DEV" metric 50 || die "Failed to direct default traffic to $TUN_DEV"
}

setup_dns() {
  log info "Setting DNS for $TUN_DEV to $DNS_SERVER"
  resolvectl dns "$TUN_DEV" "$DNS_SERVER"
  resolvectl domain "$TUN_DEV" "~."
}

restore_dns() {
  resolvectl revert "$TUN_DEV" || true
}

start_ssh_socks() {
  local base_opts=(
    -o ExitOnForwardFailure=yes
    -o ServerAliveInterval="$SSH_SERVER_ALIVE_INTERVAL"
    -o ServerAliveCountMax="$SSH_SERVER_ALIVE_COUNT_MAX"
    -o StrictHostKeyChecking=no
    -o UserKnownHostsFile=/dev/null
    -o LogLevel=ERROR
    -o ConnectTimeout=10
    -p "$SSH_PORT"
    -N
    -D "$SOCKS_HOST:$SOCKS_PORT"
    "$SSH_USER@$RESOLVED_SSH_IP"
  )

  if [[ -n "$SSH_EXTRA_OPTS" ]]; then
    # shellcheck disable=SC2206
    extra=( $SSH_EXTRA_OPTS )
    base_opts=("${extra[@]}" "${base_opts[@]}")
  fi

  if [[ $SSH_AUTH_METHOD == "password" ]]; then
    log info "Starting SSH SOCKS (password auth) to $RESOLVED_SSH_IP:$SSH_PORT"
    sshpass -f "$SSH_PASSWORD_FILE" ssh "${base_opts[@]}" > /var/tmp/ssh-socks.log 2>&1 &
  else
    log info "Starting SSH SOCKS (key auth) to $RESOLVED_SSH_IP:$SSH_PORT"
    ssh -i "$SSH_IDENTITY_FILE" "${base_opts[@]}" > /var/tmp/ssh-socks.log 2>&1 &
  fi

  SSH_PID=$!
  disown "$SSH_PID"
}

wait_for_socks_ready() {
  local attempts=${1:-12}
  local ok=0
  while (( attempts > 0 )); do
    if timeout 2 bash -c "</dev/tcp/$SOCKS_HOST/$SOCKS_PORT" 2>/dev/null; then
      ok=1
    else
      ok=0
    fi

    if (( ok == 1 )) && command -v curl >/dev/null 2>&1; then
      if timeout 6 curl -sS --socks5-hostname "$SOCKS_HOST:$SOCKS_PORT" \
        --resolve "$CHECK_TARGET":443:"$CHECK_TARGET" -k "https://$CHECK_TARGET" -o /dev/null; then
        return 0
      fi
      ok=0
    fi

    attempts=$((attempts - 1))
    log warn "SOCKS not ready; retrying in 5s (remaining=$attempts)"
    sleep 5
  done
  return 1
}

start_tun2socks() {
  pkill -f "badvpn-tun2socks.*$TUN_DEV" 2>/dev/null || true
  log info "Starting badvpn-tun2socks on $TUN_DEV"
  /usr/bin/badvpn-tun2socks --tundev "$TUN_DEV" \
    --netif-ipaddr "$TUN_IP" --netif-netmask "$TUN_NETMASK" \
    --socks-server-addr "$SOCKS_HOST:$SOCKS_PORT" > /var/tmp/badvpn-tun2socks.log 2>&1 &
  TUN2SOCKS_PID=$!
  disown "$TUN2SOCKS_PID"
}

check_connectivity() {
  local target_ip=${1:-$CHECK_TARGET}
  if command -v curl >/dev/null 2>&1; then
    if timeout 8 curl -fsS --max-time 8 --connect-timeout 4 -k "https://${target_ip}/" -o /dev/null; then
      return 0
    fi
  fi
  if timeout 4 bash -c "</dev/tcp/${target_ip}/443" 2>/dev/null; then
    return 0
  fi
  return 1
}

stop_processes() {
  if [[ -n "$SSH_PID" ]] && kill -0 "$SSH_PID" 2>/dev/null; then
    kill "$SSH_PID" 2>/dev/null || true
  fi
  if [[ -n "$TUN2SOCKS_PID" ]] && kill -0 "$TUN2SOCKS_PID" 2>/dev/null; then
    kill "$TUN2SOCKS_PID" 2>/dev/null || true
  fi
  pkill -f "badvpn-tun2socks.*$TUN_DEV" 2>/dev/null || true
}

teardown_routes() {
  ip -4 route del default dev "$TUN_DEV" 2>/dev/null || true
  ip -4 route del default prohibit 2>/dev/null || true
  if [[ -n "$GATEWAY" && -n "$IFACE" ]]; then
    ip -4 route replace default via "$GATEWAY" dev "$IFACE" metric 100 2>/dev/null || true
  fi
  if [[ -n "$RESOLVED_SSH_IP" ]]; then
    ip -4 route del "$RESOLVED_SSH_IP"/32 via "$GATEWAY" dev "$IFACE" 2>/dev/null || true
  fi
  for cidr in $LOCAL_BYPASS_CIDRS; do
    ip -4 route del "$cidr" via "$GATEWAY" dev "$IFACE" 2>/dev/null || true
  done
}

teardown_tun() {
  ip link set dev "$TUN_DEV" down 2>/dev/null || true
  ip tuntap del dev "$TUN_DEV" mode tun 2>/dev/null || true
}

stop_vpn() {
  if (( STOPPING == 1 )); then
    return
  fi
  STOPPING=1
  restore_dns
  stop_processes
  teardown_routes
  teardown_tun
  log info "Stopped and cleaned."
}

handle_signal() {
  local sig=$1
  log warn "Received $sig, stopping"
  RUNNING=0
  stop_vpn
  exit 0
}

monitor_loop() {
  while (( RUNNING == 1 )); do
    if [[ -n "$SSH_PID" ]] && ! kill -0 "$SSH_PID" 2>/dev/null; then
      log warn "SSH SOCKS process died; restarting"
      start_ssh_socks
      wait_for_socks_ready 6 || log warn "SOCKS still not ready; will retry"
    fi

    if [[ -n "$TUN2SOCKS_PID" ]] && ! kill -0 "$TUN2SOCKS_PID" 2>/dev/null; then
      log warn "badvpn-tun2socks exited; restarting"
      start_tun2socks
    fi

    if ! check_connectivity "$CHECK_TARGET"; then
      log warn "Connectivity check failed; cycling datapath"
      start_tun2socks
      if [[ -z "$SSH_PID" ]] || ! kill -0 "$SSH_PID" 2>/dev/null; then
        start_ssh_socks
      fi
    fi

    sleep "$CHECK_INTERVAL"
  done
}

start_vpn() {
  require_root
  load_config
  validate_config
  resolve_ssh_ip || die "Cannot resolve $SSH_HOST"
  ensure_gateway || die "Cannot find default gateway/interface"

  block_default_route
  add_server_route
  add_local_bypass_routes

  log info "Gateway $GATEWAY dev $IFACE; server $SSH_HOST resolved to $RESOLVED_SSH_IP; socks $SOCKS_HOST:$SOCKS_PORT"

  setup_tun
  start_ssh_socks
  if ! wait_for_socks_ready; then
    stop_processes
    teardown_routes
    teardown_tun
    restore_dns
    die "SOCKS proxy $SOCKS_HOST:$SOCKS_PORT not ready"
  fi

  start_tun2socks
  activate_tun_routes
  setup_dns
  log info "Started (tun: $TUN_DEV)."
}

trap 'handle_signal TERM' TERM
trap 'handle_signal INT' INT

start_vpn
RUNNING=1
monitor_loop
